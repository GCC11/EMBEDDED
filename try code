// =============================================
// ARDUINO FRONTEND SYSTEM (STUDENT-FRIENDLY CODE)
// Cleaner names, simpler structure, easy comments
// =============================================

// =============================================
// File: Config.h
// =============================================
#ifndef CONFIG_H
#define CONFIG_H

#include <Arduino.h>

// ----- Pin Assignments -----
const uint8_t BUTTON_MODE_PIN = 2;          // Interrupt-capable pin for switching modes
const uint8_t SENSOR_POWER_PIN = 7;         // Powers sensors on/off

// ----- Time Intervals (milliseconds) -----
const unsigned long SENSOR_UPDATE_TIME = 500;   // How often to read sensors
const unsigned long COMMS_UPDATE_TIME = 1000;   // How often to send data
const unsigned long UI_UPDATE_TIME = 200;       // How often to refresh UI (LED, etc.)

#endif

// =============================================
// File: Sensors.h
// =============================================
#ifndef SENSORS_H
#define SENSORS_H

#include <Arduino.h>

// Structure to hold sensor values
struct SensorValues {
    float sensorA;   // generic sensor value
    float sensorB;   // generic sensor value
    int sensorC;     // generic sensor value
};

class Sensors {
public:
    Sensors(uint8_t sensorPowerPin);
    void begin();
    void turnOn();
    void turnOff();
    void update();  // non-blocking
    SensorValues get();

private:
    uint8_t _pin;
    SensorValues _latest;
};

#endif

// =============================================
// File: Sensors.cpp
// =============================================
#include "Sensors.h"
#include "Config.h"

Sensors::Sensors(uint8_t sensorPowerPin) : _pin(sensorPowerPin) {
    _latest = {0, 0, 0};
}

void Sensors::begin() {
    pinMode(_pin, OUTPUT);
    turnOn(); // Start sensors ON
}

void Sensors::turnOn() {
    digitalWrite(_pin, HIGH);
}

void Sensors::turnOff() {
    digitalWrite(_pin, LOW);
}

void Sensors::update() {
    // Replace these with real sensor reads if needed
    _latest.sensorA = _latest.sensorA = analogRead(A0); // generic sensor       // Fake simple conversion
    _latest.sensorB = _latest.sensorB = analogRead(A1); // generic sensor   // Fake simple conversion
    _latest.sensorC = analogRead(A2); // generic sensor
}

SensorValues Sensors::get() {
    return _latest;
}

// =============================================
// File: Comms.h
// =============================================
#ifndef COMMS_H
#define COMMS_H

#include <Arduino.h>
#include "Sensors.h"

class Comms {
public:
    Comms(HardwareSerial &port);
    void begin(unsigned long baud);
    void send(const SensorValues &data, uint8_t mode);
    void checkIncoming();

private:
    HardwareSerial &_port;
};

#endif

// =============================================
// File: Comms.cpp
// =============================================
#include "Comms.h"

Comms::Comms(HardwareSerial &port) : _port(port) {}

void Comms::begin(unsigned long baud) {
    _port.begin(baud);
}

void Comms::send(const SensorValues &d, uint8_t mode) {
    _port.print("DATA:");
    _port.print(" mode="); _port.print(mode);
    _port.print(" sensorA="); _port.print(d.temp);
    _port.print(" sensorB="); _port.print(d.humidity);
    _port.print(" sensorC="); _port.println(d.lightLevel);
}

void Comms::checkIncoming() {
    while (_port.available()) {
        char incoming = _port.read();
        if (incoming == 'R') {
            _port.println("CMD_RECEIVED:REFRESH");
        }
    }
}

// =============================================
// File: System.ino
// =============================================
#include "Config.h"
#include "Sensors.h"
#include "Comms.h"

// ---------- System Modes ----------
enum class Mode : uint8_t {
    SLEEP = 0,
    AUTO = 1,
    MAINTENANCE = 2
};

volatile bool modeButtonPressed = false; // Set in interrupt
Mode currentMode = Mode::AUTO;

// ----- Instantiate system objects -----
Sensors sensorModule(SENSOR_POWER_PIN);
Comms communication(Serial);

// ----- Timing variables -----
unsigned long lastSensorTime = 0;
unsigned long lastCommsTime = 0;
unsigned long lastUITime = 0;

// ---------- INTERRUPT ----------
void IRAM_ATTR modeButtonISR() {
    modeButtonPressed = true; // Keep ISR fast
}

// Change to the next mode
void changeMode() {
    uint8_t nextMode = (uint8_t(currentMode) + 1) % 3;
    currentMode = (Mode) nextMode;

    // Apply behavior
    if (currentMode == Mode::SLEEP) {
        sensorModule.turnOff();
    } else {
        sensorModule.turnOn();
    }
}

void setup() {
    pinMode(BUTTON_MODE_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(BUTTON_MODE_PIN), modeButtonISR, FALLING);

    sensorModule.begin();
    communication.begin(115200);

    lastSensorTime = millis();
    lastCommsTime = millis();
    lastUITime = millis();

    pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
    unsigned long now = millis();

    // ---------- Mode Switch Handling ----------
    if (modeButtonPressed) {
        modeButtonPressed = false;
        changeMode();
    }

    // ---------- Mode Logic ----------
    switch (currentMode) {
        case Mode::SLEEP:
            // Only respond to button + comms
            break;

        case Mode::AUTO:
            if (now - lastSensorTime >= SENSOR_UPDATE_TIME) {
                sensorModule.update();
                lastSensorTime = now;
            }
            if (now - lastCommsTime >= COMMS_UPDATE_TIME) {
                communication.send(sensorModule.get(), (uint8_t)currentMode);
                lastCommsTime = now;
            }
            break;

        case Mode::MAINTENANCE:
            if (now - lastSensorTime >= SENSOR_UPDATE_TIME / 2) {
                sensorModule.update();
                lastSensorTime = now;
            }
            if (now - lastCommsTime >= COMMS_UPDATE_TIME / 2) {
                communication.send(sensorModule.get(), (uint8_t)currentMode);
                lastCommsTime = now;
            }
            break;
    }

    // ---------- UI Refresh ----------
    if (now - lastUITime >= UI_UPDATE_TIME) {
        digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
        lastUITime = now;
    }

    // ---------- Non-blocking communication ----------
    communication.checkIncoming();

    // Tiny delay allowed (<50ms)
    delay(10);
}
